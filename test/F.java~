class F{
-----Function Pair=1=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


//-----Function Pair=2=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


//-----Function Pair=3=-----==

private Exception readExceptionValue (TypeDescription type) {
    Exception value;
    try {
        value = (Exception) type.getZClass ().getConstructor (new Class [] {String.class}).newInstance (new Object [] {readStringValue ()});
    } catch (IllegalAccessException e) {
        throw new RuntimeException (e.toString ());
    } catch (InstantiationException e) {
        throw new RuntimeException (e.toString ());
    } catch (InvocationTargetException e) {
        throw new RuntimeException (e.toString ());
    } catch (NoSuchMethodException e) {
        throw new RuntimeException (e.toString ());
    }
    readFields (type, value);
    return value;
}


public Object invokeStaticMethod (final Class < ? > objectClass, final String methodName, final Class < ? > [] parameterTypes, final Object [] args) throws ReflectException {
    final Object object;
    try {
        final Method method = objectClass.getMethod (methodName, parameterTypes);
        object = method.invoke (null, args);
    } catch (SecurityException exception) {
        throw new ReflectException (FAILED_INVOKE_STATIC_METHOD, exception);
    } catch (NoSuchMethodException exception) {
        throw new ReflectException (FAILED_INVOKE_STATIC_METHOD, exception);
    } catch (IllegalArgumentException exception) {
        throw new ReflectException (FAILED_INVOKE_STATIC_METHOD, exception);
    } catch (IllegalAccessException exception) {
        throw new ReflectException (FAILED_INVOKE_STATIC_METHOD, exception);
    } catch (InvocationTargetException exception) {
        throw new ReflectException (FAILED_INVOKE_STATIC_METHOD, exception);
    }
    return object;
}


//-----Function Pair=4=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=5=-----==

public RestServiceResult create (RestServiceResult serviceResult, MaSyntaticError maSyntaticError) {
    MaSyntaticErrorDAO maSyntaticErrorDAO = new MaSyntaticErrorDAO ();
    try {
        maSyntaticError.setErrorId (getSequence ("sq_ma_syntatic_error"));
        EntityManagerHelper.beginTransaction ();
        maSyntaticErrorDAO.save (maSyntaticError);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maSyntaticError);
        log.info ("Error sintactico creado con �xito: " + maSyntaticError.getWrongSentence ());
        Object [] arrayParam = {maSyntaticError.getWrongSentence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el error sintactico: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult result, CoCourse coCourse) {
    CoCourseDAO coCourseDAO = new CoCourseDAO ();
    try {
        coCourse.setCourseId (getSequence ("sq_co_course"));
        EntityManagerHelper.beginTransaction ();
        coCourseDAO.save (coCourse);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coCourse);
        Object [] args = {coCourse.getCourseName (), coCourse.getCourseId ()};
        result.setMessage (MessageFormat.format (bundle.getString ("course.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


//-----Function Pair=6=-----==

protected void appendChopNormalCnvs () {
    String url = "jdbc:mysql://" + dbHost + ":" + dbPort + "/" + "cnv2_hg" + build + "?autoReconnect=true";
    boolean err = false;
    try {
        conn = connect (dbUser, dbPassword, url);
        String query = "select chr, start, end, type, isUnique from cnv";
        prestmt = conn.prepareStatement (query);
        resultSet = prestmt.executeQuery ();
        int rowCount = 0;
        while (resultSet.next ()) {
            String line = "chr" + resultSet.getString ("chr") + "\tchop\t";
            if (resultSet.getString ("isUnique").equals ("1")) {
                line += "uniqueCnv";
            }
            else {
                line += "nonUniqueCnv";
            }
            line += "\t" + resultSet.getString ("start") + "\t" + resultSet.getString ("end") + "\t.\t.\t.\tID=" + id + ";Note=" + resultSet.getString ("type") + "\n";
            printToFile (line);
            rowCount ++;
            id ++;
        }
        System.out.println (rowCount + " Chop Normal CNVs appended to " + outputFile + ".");
    } catch (Exception e) {
        System.err.println ("There was a problem appending Chop Normal CNVs.  " + e.getMessage ());
        err = true;
    } finally {
        try {
            close (conn, prestmt, resultSet);
        } catch (Exception e) {
            System.err.println ("There was a problem closing JDBC objects.");
            err = true;
        }
    }
    if (err) System.exit (1);
}


protected void appendCustomTrack (String dataset) {
    String url = "jdbc:mysql://" + dbHost + ":" + dbPort + "/" + "cnvCalls?autoReconnect=true";
    boolean err = false;
    try {
        conn = connect (dbUser, dbPassword, url);
        String query = "select chrom, loc_start, loc_end from cnvCalls where data_set ='" + dataset + "'";
        prestmt = conn.prepareStatement (query);
        resultSet = prestmt.executeQuery ();
        int rowCount = 0;
        while (resultSet.next ()) {
            String line = "chr" + resultSet.getString ("chrom") + "\t" + dataset + "\tcnv\t" + resultSet.getString ("loc_start") + "\t" + resultSet.getString ("loc_end") + "\t.\t.\t.\tID=" + id + ";\n";
            printToFile (line);
            rowCount ++;
            id ++;
        }
        System.out.println (rowCount + " " + dataset + " CNVs appended to " + outputFile + ".");
    } catch (Exception e) {
        System.err.println ("There was a problem appending " + dataset + " CNVs.  " + e.getMessage ());
        err = true;
    } finally {
        try {
            close (conn, prestmt, resultSet);
        } catch (Exception e) {
            System.err.println ("There was a problem closing JDBC objects.");
            err = true;
        }
    }
    if (err) System.exit (1);
}


//-----Function Pair=7=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


//-----Function Pair=8=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


//-----Function Pair=9=-----==

public boolean newComment (Usuario user, String codigoProducto, String codigoComentario, String fechaHora, String comentario) {
    Connection conexion = null;
    PreparedStatement insert = null;
    boolean exito = false;
    try {
        conexion = pool.getConnection ();
        insert = conexion.prepareStatement ("INSERT INTO " + nameBD + ".Comentarios VALUES (?,?,?,?,?,?)");
        insert.setString (1, codigoComentario);
        insert.setString (2, fechaHora);
        insert.setString (3, codigoProducto);
        insert.setString (4, user.getMail ());
        insert.setString (5, user.getNombre ());
        insert.setString (6, comentario);
        int filasAfectadas = insert.executeUpdate ();
        if (filasAfectadas == 1) {
            exito = true;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error añadiendo nuevo comentario", ex);
    } finally {
        cerrarConexionYStatement (conexion, insert);
    }
    return exito;
}


public Comentario getComment (String codComentario) {
    Comentario comment = null;
    Connection conexion = null;
    PreparedStatement select = null;
    ResultSet rs = null;
    try {
        conexion = pool.getConnection ();
        select = conexion.prepareStatement ("SELECT * FROM " + nameBD + ".Comentarios WHERE CodigoComentario=?");
        select.setString (1, codComentario);
        rs = select.executeQuery ();
        while (rs.next ()) {
            comment = new Comentario (rs.getString ("CodigoComentario"), rs.getDate ("FechaHora").toString (), rs.getTime ("FechaHora").toString (), rs.getString ("CodigoProducto"), rs.getString ("Email"), rs.getString ("Nombre"), rs.getString ("Comentario"));
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error obteniendo comentario", ex);
    } finally {
        cerrarConexionYStatement (conexion, select);
        cerrarResultSet (rs);
    }
    return comment;
}


//-----Function Pair=10=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


//-----Function Pair=11=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=12=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=13=-----==

public LinkedList < Comentario > getComentarios (String campo, String valor) {
    LinkedList < Comentario > comentarios = new LinkedList < Comentario > ();
    Connection conexion = null;
    PreparedStatement select = null;
    ResultSet rs = null;
    try {
        conexion = pool.getConnection ();
        select = conexion.prepareStatement ("SELECT * FROM " + nameBD + ".Comentarios WHERE " + campo + "=? ORDER BY FechaHora DESC");
        select.setString (1, valor);
        rs = select.executeQuery ();
        while (rs.next ()) {
            Comentario comment = new Comentario (rs.getString ("CodigoComentario"), rs.getDate ("FechaHora").toString (), rs.getTime ("FechaHora").toString (), rs.getString ("CodigoProducto"), rs.getString ("Email"), rs.getString ("Nombre"), rs.getString ("Comentario"));
            comentarios.add (comment);
        }
        if (comentarios.size () <= 0) {
            comentarios = null;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error obteniendo los comentarios", ex);
        comentarios = null;
    } finally {
        cerrarConexionYStatement (conexion, select);
        cerrarResultSet (rs);
    }
    return comentarios;
}


public List < String > getTemplateSigns (String id) {
    logger.debug ("getTemplateSigns(%s)", id);
    List < String > signsFields = new ArrayList < String > ();
    Connection connection = null;
    NamedParameterStatement statement = null;
    ResultSet resultSet = null;
    try {
        connection = this.dataSource.getConnection ();
        statement = new NamedParameterStatement (connection, this.queryStore.get (QueryStore.SELECT_TEMPLATE_SIGNS));
        statement.setString (QueryStore.SELECT_TEMPLATE_SIGNS_PARAM_ID_TEMPLATE, id);
        resultSet = statement.executeQuery ();
        while (resultSet.next ()) {
            signsFields.add (resultSet.getString (QueryStore.SELECT_TEMPLATE_SIGNS_RESULTSET_CODE));
        }
    } catch (Exception e) {
        logger.error (e.getMessage (), e);
        throw new ApplicationException (e.getMessage ());
    } finally {
        close (resultSet);
        close (statement);
        close (connection);
    }
    return signsFields;
}


//-----Function Pair=14=-----==

private static void delete (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("DELETE FROM Address");
        query.executeUpdate ();
        query = session.createQuery ("DELETE FROM Person");
        query.executeUpdate ();
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            person.getAddresses ().add (0, address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


//-----Function Pair=15=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=16=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=17=-----==

public int getUltimoIdPartida () {
    int dato = 0;
    try {
        String sql = "SELECT MAX(idPartida) FROM partida ";
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            dato = populateIdPartidas (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return dato;
}


public jugador getUnJugador (int id) {
    jugador unjugador = null;
    try {
        String sql = " SELECT * " + " FROM jugador " + " WHERE idJugador = " + id;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            this.elJugador = new jugador ();
            populateJugadores (resultSet);
            unjugador = this.elJugador;
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return unjugador;
}


//-----Function Pair=18=-----=1=

public static void zipDir (File zipDir, ZipOutputStream zos, String path, ProgressMonitor pm, Map filter) {
    try {
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                if (filter != null && filter.get (f.getAbsolutePath ()) == null) zipDir (f, zos, path + f.getName () + "/", pm, filter);
            }
            else {
                FileInputStream fis = new FileInputStream (f);
                ZipEntry anEntry = new ZipEntry (path + f.getName ());
                zos.putNextEntry (anEntry);
                while ((bytesIn = fis.read (readBuffer)) != - 1) {
                    zos.write (readBuffer, 0, bytesIn);
                    if (pm != null) pm.addToProgress (bytesIn);
                }
                fis.close ();
            }
        }
    } catch (Exception e) {
        Installer.getInstance ().getLogger ().log (StringUtils.getStackTrace (e));
    }
}


public static void doZip (final String basePath, final String directory, final ZipOutputStream zipOutputStream) throws IOException {
    log.debug ("~doZip(..) : About to zip contents of directory [" + directory + "]");
    final File zipDirectory = new File (directory);
    final String [] zipDirectoryList = zipDirectory.list ();
    final byte [] readBuffer = new byte [4096];
    int bytesIn = 0;
    for (int dirIdx = 0; dirIdx < zipDirectoryList.length; dirIdx ++) {
        final File file = new File (zipDirectory, zipDirectoryList [dirIdx]);
        if (file.isDirectory ()) {
            final String filePath = file.getPath ();
            doZip (basePath, filePath, zipOutputStream);
            continue;
        }
        final FileInputStream fileInputStream = new FileInputStream (file);
        final String zipFilePath = file.getCanonicalPath ().substring (basePath.length () + 1);
        final ZipEntry zipEntry = new ZipEntry (zipFilePath);
        zipOutputStream.putNextEntry (zipEntry);
        while ((bytesIn = fileInputStream.read (readBuffer)) != - 1) {
            zipOutputStream.write (readBuffer, 0, bytesIn);
        }
        fileInputStream.close ();
    }
}


//-----Function Pair=19=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=20=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToHandbook toHandbook) {
    ToHandbookDAO toHandbookDAO = new ToHandbookDAO ();
    try {
        log.info ("Actualizando el diario: " + toHandbook.getTitle ());
        EntityManagerHelper.beginTransaction ();
        toHandbookDAO.update (toHandbook);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toHandbook);
        Object [] args = {toHandbook.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.update.success"), args));
        log.info ("Se actualizo el diario con �xito: " + toHandbook.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el diario: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult result, CoTechnical coTechnical) {
    CoTechnicalDAO coTechnicalDAO = new CoTechnicalDAO ();
    try {
        coTechnical.setTechnicalId (getSequence ("sq_co_technical"));
        EntityManagerHelper.beginTransaction ();
        coTechnicalDAO.save (coTechnical);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coTechnical);
        Object [] args = {coTechnical.getTechnicalName (), coTechnical.getTechnicalId ()};
        result.setMessage (MessageFormat.format (bundle.getString ("technical.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar la t�cnica: " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


//-----Function Pair=21=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=22=-----==

public static void dcopyp_f77 (int nrow, double x [], double y [], int begin) {
    double temp;
    int i, m, mpbegin, end;
    m = nrow % 7;
    mpbegin = m + begin;
    end = begin + nrow - 1;
    for (i = begin; i < mpbegin; i ++) {
        y [i] = x [i];
    }
    for (i = mpbegin; i <= end; i += 7) {
        y [i] = x [i];
        y [i + 1] = x [i + 1];
        y [i + 2] = x [i + 2];
        y [i + 3] = x [i + 3];
        y [i + 4] = x [i + 4];
        y [i + 5] = x [i + 5];
        y [i + 6] = x [i + 6];
    }
    return;
}


public static void colaxpy_j (int nrow, double a, double x [] [], int begin, int j1, int j2) {
    int i, m, mpbegin, end;
    if (nrow <= 0) return;
    if (a == 0.0) return;
    m = nrow % 4;
    mpbegin = m + begin;
    end = begin + nrow - 1;
    for (i = begin; i < mpbegin; i ++) {
        x [i] [j2] += a * x [i] [j1];
    }
    for (i = mpbegin; i <= end; i += 4) {
        x [i] [j2] += a * x [i] [j1];
        x [i + 1] [j2] += a * x [i + 1] [j1];
        x [i + 2] [j2] += a * x [i + 2] [j1];
        x [i + 3] [j2] += a * x [i + 3] [j1];
    }
    return;
}


//-----Function Pair=23=-----==

public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


//-----Function Pair=24=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


//-----Function Pair=25=-----==

public List < Smilies > getIcons () {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Smilies as s where s.typeid = 0 and s.type='icon' order by s.displayorder");
        List < Smilies > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
        he.printStackTrace ();
    }
    return null;
}


public List < Attachments > findAttchmentsByJs (String hql, int startrow, int maxrow) {
    List < Attachments > attlist = new ArrayList < Attachments > ();
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery (hql);
        query.setFirstResult (startrow);
        query.setMaxResults (maxrow);
        List < Attachments > list = query.list ();
        tr.commit ();
        Iterator it = list.iterator ();
        while (it.hasNext ()) {
            Object [] os = (Object []) it.next ();
            Attachments a = (Attachments) os [0];
            Threads t = (Threads) os [1];
            attlist.add (a);
        }
        return attlist;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


//-----Function Pair=26=-----==

public List < Buddys > findBuddysByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Buddys as b where b.id.uid = ? ");
        query.setParameter (0, uid);
        List < Buddys > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
        }
        he.printStackTrace ();
    }
    return null;
}


public boolean insertMythread (Mythreads mythread) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.save (mythread);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


//-----Function Pair=27=-----==

private static void delete (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("DELETE FROM Address");
        query.executeUpdate ();
        query = session.createQuery ("DELETE FROM Person");
        query.executeUpdate ();
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            person.getAddresses ().add (0, address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


//-----Function Pair=28=-----==

public List < AcUserRelation > getAllBossPagination (Integer userId, int offset, int limit, String sort, String dir, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("from ");
        hqlSB.append (AcUserRelation.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" acUserByStaffId.id = '" + userId + "' order by " + sort + " " + dir);
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        queryObject.setFirstResult (offset);
        queryObject.setMaxResults (limit);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public List findByPropertyLike (String className, String propertyName, Object value) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + className + " as model where model." + propertyName + " like ?";
        Query queryObject = getSession ().createQuery (queryString);
        queryObject.setParameter (0, value);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


//-----Function Pair=29=-----==

protected void appendChopNormalCnvs () {
    String url = "jdbc:mysql://" + dbHost + ":" + dbPort + "/" + "cnv2_hg" + build + "?autoReconnect=true";
    boolean err = false;
    try {
        conn = connect (dbUser, dbPassword, url);
        String query = "select chr, start, end, type, isUnique from cnv";
        prestmt = conn.prepareStatement (query);
        resultSet = prestmt.executeQuery ();
        int rowCount = 0;
        while (resultSet.next ()) {
            String line = "chr" + resultSet.getString ("chr") + "\tchop\t";
            if (resultSet.getString ("isUnique").equals ("1")) {
                line += "uniqueCnv";
            }
            else {
                line += "nonUniqueCnv";
            }
            line += "\t" + resultSet.getString ("start") + "\t" + resultSet.getString ("end") + "\t.\t.\t.\tID=" + id + ";Note=" + resultSet.getString ("type") + "\n";
            printToFile (line);
            rowCount ++;
            id ++;
        }
        System.out.println (rowCount + " Chop Normal CNVs appended to " + outputFile + ".");
    } catch (Exception e) {
        System.err.println ("There was a problem appending Chop Normal CNVs.  " + e.getMessage ());
        err = true;
    } finally {
        try {
            close (conn, prestmt, resultSet);
        } catch (Exception e) {
            System.err.println ("There was a problem closing JDBC objects.");
            err = true;
        }
    }
    if (err) System.exit (1);
}


protected void appendCustomTrack (String dataset) {
    String url = "jdbc:mysql://" + dbHost + ":" + dbPort + "/" + "cnvCalls?autoReconnect=true";
    boolean err = false;
    try {
        conn = connect (dbUser, dbPassword, url);
        String query = "select chrom, loc_start, loc_end from cnvCalls where data_set ='" + dataset + "'";
        prestmt = conn.prepareStatement (query);
        resultSet = prestmt.executeQuery ();
        int rowCount = 0;
        while (resultSet.next ()) {
            String line = "chr" + resultSet.getString ("chrom") + "\t" + dataset + "\tcnv\t" + resultSet.getString ("loc_start") + "\t" + resultSet.getString ("loc_end") + "\t.\t.\t.\tID=" + id + ";\n";
            printToFile (line);
            rowCount ++;
            id ++;
        }
        System.out.println (rowCount + " " + dataset + " CNVs appended to " + outputFile + ".");
    } catch (Exception e) {
        System.err.println ("There was a problem appending " + dataset + " CNVs.  " + e.getMessage ());
        err = true;
    } finally {
        try {
            close (conn, prestmt, resultSet);
        } catch (Exception e) {
            System.err.println ("There was a problem closing JDBC objects.");
            err = true;
        }
    }
    if (err) System.exit (1);
}


//-----Function Pair=30=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


//-----Function Pair=31=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=32=-----==

private void handleDropMetaClass (DropTargetEvent evt, MetaClass mclass) {
    PIMDiagram diagram = getPIMDiagram ();
    if (mclass != null) {
        ClassNode clsNode = new ClassNode ();
        clsNode.init (mclass);
        Point loc = this.getGraphicalViewer ().getControl ().toControl (new Point (evt.x, evt.y));
        clsNode.setLocation (loc.x, loc.y);
        clsNode.setSize (0, 0);
        AddCommand addcmd = new AddCommand ();
        addcmd.setChild (clsNode);
        addcmd.setParent (diagram);
        this.getCommandStack ().execute (addcmd);
        Command cmd = PIMEditPolicy.createRefreshRelationCommand (clsNode, diagram);
        if (cmd != null && cmd.canExecute ()) {
            this.getCommandStack ().execute (cmd);
        }
    }
}


private void handleDropSubsystem (DropTargetEvent evt, Subsystem msub) {
    PIMDiagram diagram = getPIMDiagram ();
    if (msub != null) {
        SubsystemNode subNode = new SubsystemNode ();
        subNode.init (msub);
        Point loc = this.getGraphicalViewer ().getControl ().toControl (new Point (evt.x, evt.y));
        subNode.setLocation (loc.x, loc.y);
        Hashtable subsInDiagram = new Hashtable ();
        for (Iterator i = diagram.getChildren ().iterator (); i.hasNext ();) {
            Object o = i.next ();
            if (o instanceof SubsystemNode) {
                SubsystemNode node = (SubsystemNode) o;
                Subsystem sub = node.getMsubsystem ();
                if (sub != null) subsInDiagram.put (sub, node);
                if (msub == sub) {
                    evt.detail = DND.DROP_NONE;
                    return;
                }
            }
        }
        subNode.setSize (0, 0);
        AddCommand cmd = new AddCommand ();
        cmd.setChild (subNode);
        cmd.setParent (diagram);
        this.getCommandStack ().execute (cmd);
    }
}


//-----Function Pair=33=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=34=-----==

public List < Subscriptions > findSubscriptionsByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Subscriptions as s where s.id.uid=?");
        query.setParameter (0, uid);
        List < Subscriptions > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public boolean deleteMemberfields (Memberfields memberfields) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.delete (memberfields);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


//-----Function Pair=35=-----==

public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


//-----Function Pair=36=-----==

public Matrix distColumns (Matrix B) {
    checkRowDimension (B);
    Matrix X = new Matrix (n, B.n);
    double [] [] C = X.getArray ();
    for (int j = 0; j < n; j ++) {
        for (int k = 0; k < B.n; k ++) {
            double s = 0;
            for (int i = 0; i < m; i ++) {
                s = s + ((A [i] [j] - B.A [i] [k]) * (A [i] [j] - B.A [i] [k]));
            }
            C [k] [j] = Math.sqrt (s);
        }
    }
    return X;
}


public Matrix times (Matrix B) {
    if (B.m != n) {
        throw new IllegalArgumentException ("Matrix inner dimensions must agree.");
    }
    Matrix X = new Matrix (m, B.n);
    double [] [] C = X.getArray ();
    double [] Bcolj = new double [n];
    for (int j = 0; j < B.n; j ++) {
        for (int k = 0; k < n; k ++) {
            Bcolj [k] = B.A [k] [j];
        }
        for (int i = 0; i < m; i ++) {
            double [] Arowi = A [i];
            double s = 0;
            for (int k = 0; k < n; k ++) {
                s += Arowi [k] * Bcolj [k];
            }
            C [i] [j] = s;
        }
    }
    return X;
}


//-----Function Pair=37=-----==

public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


//-----Function Pair=38=-----==

public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


//-----Function Pair=39=-----==

public void UpdateTemplate (NpsContext ctxt, String content) throws NpsException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        String sql = "update template set template=empty_clob() where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "select template from Template where id=? for update";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            oracle.sql.CLOB clob = (oracle.sql.CLOB) rs.getClob (1);
            java.io.Writer writer = clob.getCharacterOutputStream ();
            writer.write (content);
            writer.flush ();
            try {
                writer.close ();
            } catch (Exception e1) {
            }
        }
        Clear ();
        DeleteJavaFiles ();
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


private void UpdateCode (NpsContext ctxt) throws Exception {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    String sql = null;
    try {
        if (code == null || code.length () == 0) {
            sql = "update job set code=empty_clob() where id=?";
            pstmt = ctxt.GetConnection ().prepareStatement (sql);
            pstmt.setString (1, id);
            pstmt.executeUpdate ();
            return;
        }
        sql = "update job set code=empty_clob() where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        sql = "select code from job where id=? for update";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            oracle.sql.CLOB clob = (oracle.sql.CLOB) rs.getClob (1);
            java.io.Writer writer = clob.getCharacterOutputStream ();
            writer.write (code);
            writer.flush ();
            try {
                writer.close ();
            } catch (Exception e1) {
            }
        }
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


//-----Function Pair=40=-----==

public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


//-----Function Pair=41=-----==

public List < Usergroups > findUserGroupByAddMember () {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("FROM Usergroups as u WHERE u.type='member' AND u.creditshigher='0' OR (u.groupid NOT IN ('5', '6', '7') AND u.radminid<>'1' AND u.type<>'member') ORDER BY u.type DESC");
        List < Usergroups > grouplist = query.list ();
        tr.commit ();
        return grouplist;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public TimeSlot delete (Integer idModel) throws TechnicalException {
    Session session = null;
    Transaction transaction = null;
    try {
        session = HibernateUtil.getCurrentSession ();
        transaction = session.beginTransaction ();
        String hql = "delete from RecurrenceRule where elementId = :id";
        Query query = session.createQuery (hql);
        query.setInteger ("id", idModel.intValue ());
        query.executeUpdate ();
        hql = "delete from TimeSlot where id = :id";
        query = session.createQuery (hql);
        query.setInteger ("id", idModel.intValue ());
        query.executeUpdate ();
        transaction.commit ();
        return null;
    } catch (HibernateException ex) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (ex);
    }
}


//-----Function Pair=42=-----==

protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    org.mxeclipse.mxgraphclipse.Map model = createInitialModel ();
    attachModelToResource (model, modelResource);
    Diagram diagram = ViewService.createDiagram (model, MapEditPart.MODEL_ID, MxgraphclipseDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        modelResource.save (org.mxeclipse.mxgraphclipse.diagram.part.MxgraphclipseDiagramEditorUtil.getSaveOptions ());
        diagramResource.save (org.mxeclipse.mxgraphclipse.diagram.part.MxgraphclipseDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        MxgraphclipseDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    Composite model = createInitialModel ();
    attachModelToResource (model, modelResource);
    Diagram diagram = ViewService.createDiagram (model, CompositeEditPart.MODEL_ID, SaveccmDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        modelResource.save (se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
        diagramResource.save (se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


//-----Function Pair=43=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=44=-----==

public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test47 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


//-----Function Pair=45=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=46=-----==

public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


//-----Function Pair=47=-----==

public Boolean setUserPassword (String NamaUser, String Password) {
    Boolean result = false;
    try {
        configEntity.getTransaction ().begin ();
        configQuery = configEntity.createNativeQuery ("UPDATE operator SET password = MD5(#password) WHERE namauser = #namauser").setParameter ("password", Password).setParameter ("namauser", NamaUser);
        configQuery.executeUpdate ();
        configEntity.getTransaction ().commit ();
        result = true;
    } catch (Exception ex) {
        configEntity.getTransaction ().rollback ();
        ex.printStackTrace ();
        Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return result;
}


private Boolean execPostingInvoice (Integer Nomor, Date Tanggal) {
    Boolean r = false;
    try {
        transaksiEntity.getTransaction ().begin ();
        transaksiQuery = transaksiEntity.createNativeQuery ("UPDATE transaksi SET posted = true WHERE nomor = #nomor AND tanggal = #tanggal").setParameter ("nomor", invoiceDisplay.format (Nomor)).setParameter ("tanggal", dateSQL.format (Tanggal));
        transaksiQuery.executeUpdate ();
        transaksiEntity.getTransaction ().commit ();
        openTransaksiForm (0, Tanggal);
        lockTransaksiForm ();
    } catch (Exception ex) {
        transaksiEntity.getTransaction ().rollback ();
        ex.printStackTrace ();
        Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return r;
}


//-----Function Pair=48=-----==

public void test118 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\"', writer.getTextQualifier ());
    writer.setTextQualifier ('\'');
    Assert.assertEquals ('\'', writer.getTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.write ("blah \'some stuff in quotes\'");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\t\'blah \'\'some stuff in quotes\'\'\'\r\n", data);
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


//-----Function Pair=49=-----==

public int addPermissionsForUserAndAgenda (Integer userId, Integer agendaId, String permissions) throws TechnicalException {
    if (permissions == null) {
        throw new TechnicalException (new Exception (new Exception ("Column 'permissions' cannot be null")));
    }
    Session session = null;
    Transaction transaction = null;
    try {
        session = HibernateUtil.getCurrentSession ();
        transaction = session.beginTransaction ();
        String query = "INSERT INTO j_user_agenda (userId, agendaId, permissions) VALUES(" + userId + "," + agendaId + ",\"" + permissions + "\")";
        Statement statement = session.connection ().createStatement ();
        int rowsUpdated = statement.executeUpdate (query);
        transaction.commit ();
        return rowsUpdated;
    } catch (HibernateException ex) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (ex);
    } catch (SQLException e) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (e);
    }
}


public boolean modifyRanks (Ranks rank) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.update (rank);
        tr.commit ();
        return true;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


//-----Function Pair=50=-----==

public static double [] [] singleRotation (double [] [] loadingFactorMatrix, int k, int l, double angle) {
    int nRows = loadingFactorMatrix.length;
    int nColumns = loadingFactorMatrix [0].length;
    double [] [] rotatedMatrix = new double [nRows] [nColumns];
    for (int i = 0; i < nRows; i ++) {
        for (int j = 0; j < nColumns; j ++) {
            rotatedMatrix [i] [j] = loadingFactorMatrix [i] [j];
        }
    }
    double sinphi = Math.sin (angle);
    double cosphi = Math.cos (angle);
    for (int j = 0; j < nColumns; j ++) {
        rotatedMatrix [k] [j] = loadingFactorMatrix [k] [j] * cosphi + loadingFactorMatrix [l] [j] * sinphi;
        rotatedMatrix [l] [j] = - loadingFactorMatrix [k] [j] * sinphi + loadingFactorMatrix [l] [j] * cosphi;
    }
    return rotatedMatrix;
}


public float [] [] mtxMargin (final float [] [] mtx) {
    int nrow = mtx.length;
    int ncol = mtx [0].length;
    float [] margCol = new float [ncol];
    float [] margRow = new float [nrow];
    for (int j = 0; j < ncol; j ++) {
        for (int i = 0; i < nrow; i ++) {
            margCol [j] += mtx [i] [j];
        }
    }
    for (int i = 0; i < nrow; i ++) {
        for (int j = 0; j < ncol; j ++) {
            margRow [i] += mtx [i] [j];
        }
    }
    float [] [] margin = new float [2] [];
    margin [0] = margRow;
    margin [1] = margCol;
    return (margin);
}


//-----Function Pair=51=-----==

public Schema create () {
    Session session = getSession ();
    Transaction tx = null;
    try {
        tx = session.beginTransaction ();
        session.save (this);
        tx.commit ();
        tx = null;
        session.refresh (this);
    } catch (HibernateException e) {
        if (tx != null) tx.rollback ();
        e.printStackTrace ();
        return null;
    } finally {
        session.close ();
    }
    return this;
}


public List < Profilefields > findAllProfilefields () {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Profilefields");
        List < Profilefields > profileList = query.list ();
        tr.commit ();
        return profileList;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


//-----Function Pair=52=-----==

private Vector list () throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        prepareRenderer (r, "");
        sql = r.getSQLSelect ("adm_applicant", "apply_date");
        ResultSet rs = stmt.executeQuery (sql);
        Vector v = new Vector ();
        while (rs.next ()) {
            v.addElement (getApplicantData (rs));
        }
        return v;
    } catch (DbException dbex) {
        throw dbex;
    } catch (SQLException sqlex) {
        throw sqlex;
    } finally {
        if (db != null) db.close ();
    }
}


public static Hashtable getStudent (String student) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("id", student);
        r.add ("name");
        sql = r.getSQLSelect ("student");
        ResultSet rs = stmt.executeQuery (sql);
        Hashtable h = new Hashtable ();
        if (rs.next ()) {
            h.put ("id", student);
            h.put ("name", rs.getString ("name"));
        }
        return h;
    } finally {
        if (db != null) db.close ();
    }
}


//-----Function Pair=53=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=54=-----==

public static void fixTabSequence (String usrlogin) throws DbException {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        conn = db.getConnection ();
        conn.setAutoCommit (false);
        Statement stmt = db.getStatement ();
        boolean fix = false;
        {
            sql = "SELECT sequence FROM tab_template WHERE user_login = '" + usrlogin + "' AND sequence = 0";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) fix = true;
        }
        if (fix) {
            Vector v = new Vector ();
            sql = "SELECT tab_id FROM tab_template WHERE user_login = '" + usrlogin + "'";
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                String tab_id = rs.getString ("tab_id");
                v.addElement (tab_id);
            }
            for (int i = 0; i < v.size (); i ++) {
                String tab_id = (String) v.elementAt (i);
                sql = "UPDATE tab_template SET sequence = " + Integer.toString (i + 1) + " WHERE tab_id = '" + tab_id + "' AND user_login = '" + usrlogin + "'";
                Log.print (sql);
                stmt.executeUpdate (sql);
            }
        }
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException exr) {
        }
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public static void updateRSSLocation (String module_id, String rss) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        boolean found = false;
        {
            sql = "SELECT module_id FROM rss_module WHERE module_id = '" + module_id + "' ";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        if (found) sql = "UPDATE rss_module SET rss_source = '" + rss + "' WHERE module_id = '" + module_id + "' ";
        else sql = "INSERT INTO rss_module (module_id, rss_source) VALUES ('" + module_id + "', '" + rss + "')";
        stmt.executeUpdate (sql);
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


//-----Function Pair=55=-----==

public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


//-----Function Pair=56=-----==

public List < Favorites > findFavoritesByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Favorites as f where f.id.uid=?");
        query.setParameter (0, uid);
        List < Favorites > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public void removeClient (int id) throws OldVersionException, MyHibernateException, MyObjectNotFoundException, OSActiveException {
    Session session = HibernateUtil.getCurrentSession ();
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction ();
        clientDAO.delete (session, id);
        transaction.commit ();
    } catch (RuntimeException ex) {
        if (transaction != null) {
            transaction.rollback ();
        }
        if (ex instanceof StaleObjectStateException) {
            throw new OldVersionException (ex);
        }
        else if (ex instanceof ObjectNotFoundException) {
            throw new MyObjectNotFoundException (ex);
        }
        else if (ex instanceof HibernateException) {
            throw new MyHibernateException ((HibernateException) ex);
        }
        throw ex;
    } finally {
        if (session != null && session.isOpen ()) {
            session.close ();
        }
    }
}


//-----Function Pair=57=-----==

public void testQueries () throws Exception {
    _messages.clear ();
    _shouldRun = true;
    Thread [] udpLoopers = new Thread [NUM_UDP_LOOPS];
    for (int i = 0; i < NUM_UDP_LOOPS; i ++) {
        final int index = i;
        udpLoopers [i] = new Thread () {
            public void run () {
                udpLoop (5000 + index);
            }
        }
        ;
        udpLoopers [i].start ();
        Thread.yield ();
    }
    InetAddress addr = null;
    addr = InetAddress.getByName ("127.0.0.1");
    for (int i = 0; i < NUM_UDP_LOOPS; i ++) {
        queryUnicaster.addUnicastEndpoint (addr, 5000 + i);
        if (i % 5 == 0) {
            try {
                Thread.sleep (200);
            } catch (InterruptedException ignored) {
            }
        }
    }
    QueryRequest qr = queryRequestFactory.createQuery ("susheel", (byte) 2);
    assertEquals ("unexpected number of queries", 0, queryUnicaster.getQueryNumber ());
    queryUnicaster.addQuery (qr, null);
    assertEquals ("unexpected number of queries", 1, queryUnicaster.getQueryNumber ());
    try {
        Thread.sleep (30 * 1000);
    } catch (InterruptedException ignored) {
    }
    int numMessages = 0, numQRs = 0, numPings = 0, numQKReqs = 0;
    while (! _messages.isEmpty ()) {
        Message currMessage = (Message) _messages.remove (0);
        numMessages ++;
        if (currMessage instanceof QueryRequest) {
            QueryRequest currQR = (QueryRequest) currMessage;
            assertEquals ("unexpected query", "susheel", currQR.getQuery ());
            numQRs ++;
        }
        else if (currMessage instanceof PingRequest) {
            numPings ++;
            if (((PingRequest) currMessage).isQueryKeyRequest ()) numQKReqs ++;
        }
        else fail ("unexpected message: " + currMessage);
    }
    assertEquals ("unexpected number of messages", numMessages, numPings + numQRs);
    assertLessThanOrEquals ("unexpected number of QRs", numPings, numQRs);
    assertGreaterThan ("unexpected number of QRs", 0, numQRs);
    assertLessThanOrEquals ("unexpected number of QRs", numQKReqs, numQRs);
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("QueryUnicasterTest.testQueries(): numMessages = " + numMessages);
        LOG.debug ("QueryUnicasterTest.testQueries(): numQRs = " + numQRs);
        LOG.debug ("QueryUnicasterTest.testQueries(): numPings = " + numPings);
    }
    _shouldRun = false;
    for (int i = 0; i < NUM_UDP_LOOPS; i ++) udpLoopers [i].interrupt ();
    try {
        Thread.sleep (2 * 1000);
    } catch (InterruptedException ignored) {
    }
    QueryReply qRep = generateFakeReply (qr.getGUID (), 251);
    queryUnicaster.handleQueryReply (qRep);
}


public void testResultMaxOut () throws Exception {
    _messages.clear ();
    _shouldRun = true;
    Thread [] udpLoopers = new Thread [NUM_UDP_LOOPS];
    for (int i = 0; i < NUM_UDP_LOOPS; i ++) {
        final int index = i;
        udpLoopers [i] = new Thread () {
            public void run () {
                udpLoop (5000 + index);
            }
        }
        ;
        udpLoopers [i].start ();
        Thread.yield ();
    }
    QueryRequest qr = queryRequestFactory.createQuery ("Daswani", (byte) 2);
    queryUnicaster.addQuery (qr, null);
    InetAddress addr = null;
    addr = InetAddress.getByName ("127.0.0.1");
    for (int i = 0; i < NUM_UDP_LOOPS; i ++) {
        queryUnicaster.addUnicastEndpoint (addr, 5000 + i);
        if (i % 5 == 0) {
            try {
                Thread.sleep (200);
            } catch (InterruptedException ignored) {
            }
        }
        int low = 250 / NUM_UDP_LOOPS + 1;
        int hi = 254 / NUM_UDP_LOOPS + 1;
        if (low < 25) low = 25;
        if (hi < 35) hi = 35;
        QueryReply qRep = generateFakeReply (qr.getGUID (), getNumberBetween (low, hi));
        queryUnicaster.handleQueryReply (qRep);
    }
    try {
        Thread.sleep (30 * 1000);
        assertEquals ("unexpected number of queries", 0, queryUnicaster.getQueryNumber ());
    } catch (InterruptedException ignored) {
    }
    int numMessages = 0, numQRs = 0, numPings = 0;
    while (! _messages.isEmpty ()) {
        Message currMessage = (Message) _messages.remove (0);
        numMessages ++;
        if (currMessage instanceof QueryRequest) {
            QueryRequest currQR = (QueryRequest) currMessage;
            assertEquals ("daswani", currQR.getQuery ());
            numQRs ++;
        }
        else if (currMessage instanceof PingRequest) {
            numPings ++;
        }
        else fail ("unexpected message: " + currMessage);
    }
    assertEquals ("unexpected number of messages", numMessages, numPings + numQRs);
    assertLessThan ("unexpected number of QRs", 11, numQRs);
    if (NUM_UDP_LOOPS > 10) assertGreaterThan ("unexpected endpoint size", 0, queryUnicaster.getUnicastEndpoints ().size ());
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("QueryUnicasterTest.testQueries(): numMessages = " + numMessages);
        LOG.debug ("QueryUnicasterTest.testQueries(): numQRs = " + numQRs);
        LOG.debug ("QueryUnicasterTest.testQueries(): numPings = " + numPings);
    }
    _shouldRun = false;
    for (int i = 0; i < NUM_UDP_LOOPS; i ++) udpLoopers [i].interrupt ();
    try {
        Thread.sleep (2 * 1000);
    } catch (InterruptedException ignored) {
    }
}


//-----Function Pair=58=-----==

public boolean delteFavoritesByFid (short fid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Favorites as f where f.id.fid=?");
        query.setParameter (0, fid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public List < Attachments > findByattaByTid (Integer tid) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Attachments as a where a.tid=?");
        query.setParameter (0, tid);
        List < Attachments > list = query.list ();
        tr.commit ();
        return list;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


//-----Function Pair=59=-----==

public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


//-----Function Pair=60=-----==

public Integer deleteSmiliesIds (List < Short > list) {
    Integer num = - 1;
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Smilies as s where s.id in (:ids)");
        query.setParameterList ("ids", list, new ShortType ());
        num = query.executeUpdate ();
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
        he.printStackTrace ();
        num = 0;
    }
    return num;
}


public Integer deleteImagetypesAll (Short [] ids) {
    Transaction tr = null;
    Integer num = 0;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Smilies as s where s.typeid in (:typeids)");
        query.setParameterList ("typeids", ids);
        query.executeUpdate ();
        query = session.createQuery ("delete from Imagetypes as i where i.typeid in (:typeids)");
        query.setParameterList ("typeids", ids);
        query.executeUpdate ();
        session.flush ();
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
    }
    return num;
}


//-----Function Pair=61=-----==

public void test47 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


//-----Function Pair=62=-----==

public List < Projects > findAllProjects () {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Projects");
        List < Projects > list = query.list ();
        tr.commit ();
        return list;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public TimeSlot delete (Integer idModel) throws TechnicalException {
    Session session = null;
    Transaction transaction = null;
    try {
        session = HibernateUtil.getCurrentSession ();
        transaction = session.beginTransaction ();
        String hql = "delete from RecurrenceRule where elementId = :id";
        Query query = session.createQuery (hql);
        query.setInteger ("id", idModel.intValue ());
        query.executeUpdate ();
        hql = "delete from TimeSlot where id = :id";
        query = session.createQuery (hql);
        query.setInteger ("id", idModel.intValue ());
        query.executeUpdate ();
        transaction.commit ();
        return null;
    } catch (HibernateException ex) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (ex);
    }
}


//-----Function Pair=63=-----==

public RestServiceResult update (RestServiceResult serviceResult, List listWordsComleteE2, Long nCompleteId) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_COMPLETE1_WORD);
        query.setParameter (1, new Long (nCompleteId));
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        if (listWordsComleteE2 != null) {
            for (int i = 0; i < listWordsComleteE2.size (); i ++) {
                CoWordsCompleteE1 coWordsCompleteE1 = (CoWordsCompleteE1) listWordsComleteE2.get (i);
                serviceResult = this.create (serviceResult, coWordsCompleteE1);
            }
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar las palabras: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, MaSpell maSpell) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_MA_SPELL);
        query.setParameter (1, maSpell.getWordId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {maSpell.getWord ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la palbra: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {maSpell.getWord ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


//-----Function Pair=64=-----==

public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


//-----Function Pair=65=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


//-----Function Pair=66=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=67=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


//-----Function Pair=68=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


//-----Function Pair=69=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=70=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


//-----Function Pair=71=-----==

protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    EPackage model = createInitialModel ();
    attachModelToResource (model, modelResource);
    Diagram diagram = ViewService.createDiagram (model, EPackageEditPart.MODEL_ID, EcoreDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        modelResource.save (fr.fous.ecore.part.EcoreDiagramEditorUtil.getSaveOptions ());
        diagramResource.save (fr.fous.ecore.part.EcoreDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        EcoreDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    Filesystem model = createInitialModel ();
    attachModelToResource (model, modelResource);
    Diagram diagram = ViewService.createDiagram (model, FilesystemEditPart.MODEL_ID, FilesystemDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        modelResource.save (filesystem.diagram.part.FilesystemDiagramEditorUtil.getSaveOptions ());
        diagramResource.save (filesystem.diagram.part.FilesystemDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        FilesystemDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


//-----Function Pair=72=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=73=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test118 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\"', writer.getTextQualifier ());
    writer.setTextQualifier ('\'');
    Assert.assertEquals ('\'', writer.getTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.write ("blah \'some stuff in quotes\'");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\t\'blah \'\'some stuff in quotes\'\'\'\r\n", data);
}


//-----Function Pair=74=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=75=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=76=-----==

public void test47 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


//-----Function Pair=77=-----==

public static int save (File inputFile, File outputFile) throws IOException {
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new FileInputStream (inputFile);
        outputFile.getParentFile ().mkdirs ();
        out = new FileOutputStream (outputFile);
    } catch (Exception e) {
        e.getMessage ();
    }
    try {
        return IOUtils.copy (in, out);
    } finally {
        IOUtils.closeQuietly (in);
        IOUtils.closeQuietly (out);
        try {
            if (out != null) {
                out.close ();
            }
        } catch (IOException ioe) {
            ioe.getMessage ();
        }
        try {
            if (in != null) {
                in.close ();
            }
        } catch (IOException ioe) {
            ioe.getMessage ();
        }
    }
}


public static void downloadAndSaveFile (URL source, File destination, int fileSize, int bufferSize, Point centerPoint) throws IOException {
    OutputStream destinationFile = null;
    InputStream fileStream = null;
    try {
        destinationFile = new FileOutputStream (destination);
        fileStream = source.openStream ();
        byte [] buf = new byte [bufferSize * 1024];
        int bytesRead = 0;
        while ((bytesRead = fileStream.read (buf)) != - 1) {
            destinationFile.write (buf, 0, bytesRead);
        }
    } catch (FileNotFoundException e) {
        throw new IOException (e);
    } catch (IOException e) {
        throw new IOException (e);
    } finally {
        StreamUtil.closeStream (fileStream);
        StreamUtil.closeStream (destinationFile);
    }
}


//-----Function Pair=78=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Order o");
        query.executeUpdate ();
        Query query2 = entityManager.createQuery ("DELETE FROM OrderItem i");
        query2.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


//-----Function Pair=79=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


//-----Function Pair=80=-----==

public AcademicYear store (AcademicYear obj) throws InsertException, DBConnectionException, XmlIOException {
    AcademicYear toReturn = null;
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    List < Object > values = new ArrayList < Object > ();
    values.add (0);
    values.add (obj.getName ());
    try {
        stmt.executeUpdate (new InsertQuery (AcademicYearDAO.TABLE_NAME, values).toString ());
        toReturn = findByName (obj.getName ());
        if (toReturn == null) {
            throw new SelectException (TABLE_NAME + " Can't retieve record");
        }
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new InsertException (TABLE_NAME + " Insert Exception :", e);
    }
    return toReturn;
}


public SessionType store (SessionType obj) throws InsertException, DBConnectionException, XmlIOException {
    SessionType toReturn = null;
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    List < Object > values = new ArrayList < Object > ();
    values.add (0);
    values.add (obj.getName ());
    values.add (obj.getEquivTuto ());
    values.add (obj.getAcronym ());
    try {
        stmt.executeUpdate (new InsertQuery (TABLE_NAME, values).toString ());
        toReturn = findByAcronym (obj.getAcronym ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new InsertException (TABLE_NAME + " Insert Exception :", e);
    }
    return toReturn;
}


//-----Function Pair=81=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


//-----Function Pair=82=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=83=-----==

public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


//-----Function Pair=84=-----==

public List < Job > getJobs () {
    List < Job > jobs = null;
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        Query query = session.createQuery ("from " + JOB_TABLE + " o ");
        jobs = query.list ();
        transaction.commit ();
    } catch (HibernateException e) {
        if (transaction != null) transaction.rollback ();
        throw e;
    }
    return jobs;
}


public Set < Job > getNotFinishedJobs () {
    Set < Job > jobs = new HashSet < Job > ();
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        Query query = session.createQuery ("from " + JOB_TABLE + " o where " + "o.status != :finished AND " + "o.status != :errors AND " + "o.status != :canceled");
        query.setString ("finished", JobStatus.FINISHED.getStatus ());
        query.setString ("errors", JobStatus.ERRORS.getStatus ());
        query.setString ("canceled", JobStatus.CANCELED.getStatus ());
        List jobList = query.list ();
        for (Object o : jobList) {
            jobs.add ((Job) o);
        }
        transaction.commit ();
    } catch (HibernateException e) {
        if (transaction != null) transaction.rollback ();
        throw e;
    }
    return jobs;
}


//-----Function Pair=85=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


//-----Function Pair=86=-----==

public void test117 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('#', writer.getComment ());
    writer.setComment ('~');
    Assert.assertEquals ('~', writer.getComment ());
    writer.setRecordDelimiter (';');
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1;~blah;", data);
}


public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


//-----Function Pair=87=-----==

public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


//-----Function Pair=88=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


//-----Function Pair=89=-----==

private void sendBufferToClient (final ByteBuffer buf, final String expectedMsgString, final Delivery delivery) throws Exception {
    final String name = "dummy";
    DummyClient client = createDummyClient (name);
    try {
        client.connect (serverNode.getAppPort ());
        assertTrue (client.login ());
        final int numMessages = 3;
        for (int i = 0; i < numMessages; i ++) {
            txnScheduler.runTask (new TestAbstractKernelRunnable () {
                public void run () {
                    ClientSession session = (ClientSession) AppContext.getDataManager ().getBinding (name);
                    System.err.println ("Sending messages");
                    session.send (buf, delivery);
                }
            }
            , taskOwner);
        }
        System.err.println ("waiting for client to receive messages");
        client.waitForClientToReceiveExpectedMessages (numMessages);
        for (byte [] message : client.clientReceivedMessages) {
            if (message.length == 0) {
                fail ("message buffer emtpy");
            }
            String msgString = (new MessageBuffer (message)).getString ();
            if (! msgString.equals (expectedMsgString)) {
                fail ("expected: " + expectedMsgString + ", received: " + msgString);
            }
            else {
                System.err.println ("received expected message: " + msgString);
            }
        }
    } finally {
        client.disconnect ();
    }
}


public void testLocalSendPerformance () throws Exception {
    final String user = "dummy";
    DummyClient client = createDummyClient (user);
    assertTrue (client.connect (serverNode.getAppPort ()).login ());
    int numIterations = 10;
    final ByteBuffer msg = ByteBuffer.allocate (0);
    long startTime = System.currentTimeMillis ();
    for (int i = 0; i < numIterations; i ++) {
        txnScheduler.runTask (new TestAbstractKernelRunnable () {
            public void run () {
                DataManager dataManager = AppContext.getDataManager ();
                ClientSession session = (ClientSession) dataManager.getBinding (user);
                session.send (msg);
            }
        }
        , taskOwner);
    }
    long endTime = System.currentTimeMillis ();
    System.err.println ("send, iterations: " + numIterations + ", elapsed time: " + (endTime - startTime) + " ms.");
}


//-----Function Pair=90=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToExercise1Group toExercise1Group) {
    ToExercise1GroupDAO toExercise1GroupDAO = new ToExercise1GroupDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        toExercise1GroupDAO.update (toExercise1Group);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toExercise1Group);
        Object [] args = {toExercise1Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.update.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio grupal s1: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult result, CoScoreExercises1 coScoreExercises1) {
    CoScoreExercises1DAO coScoreExercises1DAO = new CoScoreExercises1DAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        coScoreExercises1DAO.save (coScoreExercises1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coScoreExercises1);
        Object [] args = {coScoreExercises1.getMaUser ().getUserName ()};
        result.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises1.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        result.setError (true);
        Object [] args = {coScoreExercises1.getMaUser ().getUserName ()};
        result.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises1.create.error"), args));
        log.error ("Error al guardar la calificaci�n para el ejercicio de tipo 1: " + e.getMessage ());
    }
    return result;
}


//-----Function Pair=91=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


//-----Function Pair=92=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setUniquePersonNumber ("1234-567");
        person.setUpnIssuer ("FRO-TX");
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        person.setImage (new byte [] {0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, (byte) 0xff});
        person.setProfile (generateLongText ());
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


//-----Function Pair=93=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        query = entityManager.createQuery ("DELETE FROM Address a");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


//-----Function Pair=94=-----==

public RestServiceResult delete (RestServiceResult serviceResult, ToHandbook toHandbook) {
    try {
        log.info ("Eliminando anotaci�n libreta: " + toHandbook.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_HANDBOOK);
        query.setParameter (1, toHandbook.getHandbookId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toHandbook);
        Object [] arrayParam = {toHandbook.getTitle ()};
        log.info ("Libreta eliminado con �xito: " + toHandbook.getTitle ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el Libreta: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toHandbook.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


public RestServiceResult update (RestServiceResult serviceResult, ToDaily toDaily) {
    ToDailyDAO toDailyDAO = new ToDailyDAO ();
    try {
        log.info ("Actualizando el diario: " + toDaily.getTitle ());
        EntityManagerHelper.beginTransaction ();
        toDailyDAO.update (toDaily);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toDaily);
        Object [] args = {toDaily.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("daily.update.success"), args));
        log.info ("Se actualizo el diario con �xito: " + toDaily.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el diario: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("daily.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


//-----Function Pair=95=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=96=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


//-----Function Pair=97=-----==

public RestServiceResult delete (RestServiceResult serviceResult, MaUser maUser) {
    MaUserDAO maUserDAO = new MaUserDAO ();
    try {
        log.info ("Eliminando el usuario: " + maUser.getUserName ());
        EntityManagerHelper.beginTransaction ();
        maUserDAO.delete (maUser);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maUser);
        Object [] arrayParam = {maUser.getUserName ()};
        log.info ("Usuario eliminado con �xito: " + maUser.getUserName ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la secuencia: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {maUser.getUserName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult result, ToGlossary toGlossary) {
    ToGlossaryDAO toGlossaryDAO = new ToGlossaryDAO ();
    try {
        toGlossary.setGlossaryId (getSequence ("sq_to_glossary"));
        EntityManagerHelper.beginTransaction ();
        toGlossaryDAO.save (toGlossary);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toGlossary);
        Object [] args = {toGlossary.getTerm (), toGlossary.getGlossaryId ()};
        result.setMessage (MessageFormat.format (bundle.getString ("glossary.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar el termino del glosario : " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


//-----Function Pair=98=-----==

public boolean marshall (PackagePart part, OutputStream os) throws OpenXML4JException {
    if (! (os instanceof ZipOutputStream)) {
        logger.error ("ZipOutputSTream expected!" + os.getClass ().getName ());
        throw new OpenXML4JException ("ZipOutputSTream expected!");
    }
    ZipOutputStream out = (ZipOutputStream) os;
    ZipEntry ctEntry = new ZipEntry (part.getPartName ().getURI ().getPath ());
    try {
        out.putNextEntry (ctEntry);
        if (! StreamHelper.saveXmlInStream (content, out)) {
            return false;
        }
        logger.debug ("recording word doc relationship");
        if (part.hasRelationships ()) {
            ZipPartMarshaller.marshallRelationshipPart (part.getRelationships (), PackagingURIHelper.getRelationshipPartName (part.getPartName ()), out);
        }
        out.closeEntry ();
    } catch (IOException e1) {
        logger.error ("IO problem with " + part.getPartName (), e1);
        return false;
    }
    return true;
}


public boolean marshall (PackagePart part, OutputStream os) throws OpenXML4JException {
    if (! (os instanceof ZipOutputStream)) {
        logger.error ("unexpected class " + os.getClass ().getName ());
        throw new OpenXML4JException ("ZipOutputStream expected !");
    }
    ZipOutputStream zos = (ZipOutputStream) os;
    ZipEntry partEntry = new ZipEntry (part.uri.getPath ());
    try {
        zos.putNextEntry (partEntry);
        InputStream ins = part.getInputStream ();
        byte [] buff = new byte [OpenXMLDocument.READ_WRITE_FILE_BUFFER_SIZE];
        while (ins.available () > 0) {
            int resultRead = ins.read (buff);
            if (resultRead == - 1) {
                break;
            }
            else {
                zos.write (buff, 0, resultRead);
            }
        }
        zos.closeEntry ();
    } catch (IOException ioe) {
        logger.error ("cannot write:" + part.uri + ": in ZIP", ioe);
        return false;
    }
    if (part.hasRelationships ()) {
        marshallRelationshipPart (part.getRelationships (), PackageURIHelper.getRelationshipPartUri (part.getUri ()), zos);
    }
    return true;
}


//-----Function Pair=99=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


//-----Function Pair=100=-----==

public void update (UserSchedule us) throws HibernateException {
    Session session = mpower_hibernate.HibernateUtil.currentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        String hql = "update UserSchedule set Status = ? where UserScheduleId = ?";
        Query query = session.createQuery (hql);
        query.setString (0, us.getStatus ());
        query.setLong (1, us.getUserScheduleId ());
        int rowCount = query.executeUpdate ();
        tx.commit ();
    } catch (HibernateException e) {
        tx.rollback ();
        throw e;
    } finally {
        mpower_hibernate.HibernateUtil.closeSession ();
    }
}


public void delete (long deviceTypesId) {
    Session session = mpower_hibernate.HibernateUtil.currentSession ();
    Transaction transaction = session.beginTransaction ();
    try {
        org.hibernate.Query query = session.createQuery (" delete " + " from  " + " DeviceTypes lr WHERE lr.id = ? ");
        query.setLong (0, deviceTypesId);
        query.executeUpdate ();
        transaction.commit ();
    } catch (HibernateException e) {
        transaction.rollback ();
        throw e;
    } finally {
        mpower_hibernate.HibernateUtil.closeSession ();
    }
}
}


